שלום, אשמח להשתמש בקובץ זה כדי להסביר איך בניתי את הפרוייקט, כמו שאתם רואים לא השתמשתי באלגורתם שהוצע בממן, אז איך האלגוריתם שלי עובד?
כדי להכין את האלגורתם שלי לקחתי השראה מהדרך שבא GCC ישם את קו pipeline שלו.

לדוגמה, כל מופע של משהו בעל משמעות בקובץ המקור יחולק ל tokens לדוגמה בו ניקח הצצה על החלוקה ל tokens של הדוגמה הבאה:
labal: add r3, r6
            stop

אז בדוגמה הזאת ה tokens שלנו יהיו מסודרים כך:
labal
:
add
r3
,
r6
\n
stop

כמו שניתן לראות את לאחר המעבר מקובץ לרשימה של tokens קיבלנו מאין תמצית של כל הדברים החשובים בקובץ, אז לאין מפה ממשיכים?
מפה אנחנו ממשיכים ל preprocessor.c שם מתבצעת הפתיחה של כל המקרואים והמעבר לקובץ .am, ואז משם לאין הולכים?
משם אנחנו ממשיכים ל parser.c אשר לוקח את רשימת ה tokens שלנו ומנסה ליצור ממנה הגיון או בשפה אחרת AST (Abstract Syntax Tree).
כדי לעשות זאת ה parser משתמש בישום של התחביר שרשמנו לו בקובץ GRAMMAR. אז מאין מפה הולכים?

מפה אנחנו הולכים ל ast_checker.c אשר בודק את הנכונות של ה AST שלנו, לדוגמה אולי תחבירית מותר לעשות:
labal: add #55, #55
אך אי לזה אף משמעות כי איאפשר להוסיף 55 ל55 מבלי לשמור את זה במקום כלשהו. ואז מפה לאין הולכים?

מפה הולכים ל emitter.c שתפקידו הוא להוציא את כל שאר הקבצים שאנחנו צריכים, כלומר .ext .ent .ob, כמובן שאם היתה שגיאה בדרך ה emitter לא יעשה את העבודתו ולא ידפיס כלום.

הערות ודגשים בשימוש בפרוייקט:
1) אין לערבב משפטי הנחיה ומשפט הוראה בו זמנית אותה תווית, לדוגמה התווית הבאה תהיה לא נכונה תחבירית ולכן תגרור להופעת שגיאה על ידי התוכנה:
labal: .string "Asdfdsfa"
    stop

2) האפשרות לשים הערות בכל מקום בין אם השורה ריקה ובין אם לא איננה טעות והינה דבר מכוון אשר התאפשר בזכות הקלות של השימוש ב tokens, הנה לפניכם דוגמה כדי להמחיש את הדבר:
; this is ok
testComment: jmp PRINT ; this is ok
               ; this and the following comments are also ok
    ;

3) אפשרות להגדרת תווית ללא הוראה בידיוק באותה שורה איננה טעות והינה דבר מכוון שוב בגלל הקלות של השימוש ב tokens, לפניכם דוגמה כדי להמחיש את הדבר:
thisIsOk: 
          add #454, *r3
    bne XYZ

4) אין לרשום שני שורות extern/entry בעלות אותו identifier, לפיכך הדוגמה הבאה אסורה ותגרום להופעת שגיאה על ידי התוכנה:
.extern id1
.extern id1
.entry id2
.entry id2